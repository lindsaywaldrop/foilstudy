---
title: "Generating parameter spaces using gPC expansion"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup}
library(pracma)
library(spacefillr)
library(ggplot2)
library(patchwork)
```

Based on Nick Battista's MATLAB code. 

### Producing gPC parameter space

Load custom functions: 

```{r}
source("./src/r-scripts/gPC_functions.R")
source("./src/r-scripts/gpc_user_specified_model.R")
```

Initial parameters: 

 - `test_flag` will test the results against expected values produced by the code in MATLAB.`TRUE` should be displayed in the output of each code chunk (at least once) if testing is successful. If you wish to intrinsically validate this code, use `1` to test, otherwise `0` will turn testing off. 

```{r initial-parameters}
test_flag <- 0
```

Set gPC parameters:

 - `n`: the number of parameters in your data set. 
 - `p`: the order of polynomial you wish to use. Using lower values of `p` may not capture non-linear aspects of the performance space, but will require fewer full simulations. Higher `p` will require more simulations.

```{r set-gpc-parameters}
n <- 3
p <- 6
cap_p <- nchoosek(n + p, p)
```

Find collocation points:

```{r collocation-points}
poly_roots <- Legendre_roots(p + 1, test_flag)
```

Find combinations of all collocation points: 

```{r}
param_combo <- compute_all_collo_pt_combos(n, poly_roots, test_flag)
```

Get subset of all parameter combinations for least squares: 

```{r}
n_subset <- 1 * (n - 1) * cap_p
param_combo_subset <- sample_parameter_combos(n_subset, param_combo, test_flag)
```


#### Evaluate and test parameter combinations

Multivariable Legendre polynomial ordering:

```{r}
alpha_mat <- create_polynomial_ordering(n, p, test_flag)
```

Create information matrix: 

```{r}
info_mat <- create_info_matrix(n, p, cap_p, param_combo_subset, alpha_mat, test_flag)
```

Evaluate user-specified model for particular parameter combos:

```{r}
Y <- rep(0, nrow(param_combo_subset))
for(i in 1:nrow(param_combo_subset)){
  Y[i] <- user_specified_model(param_combo_subset[i, ])
}

# testing against matlab values:
if(test_flag == 1){
  matlab_Y <- read.csv("./test/gpc_matlab/Y.csv", header = F)
  all.equal(Y, matlab_Y[, 1])
}
```

Solve for coefficients via least-squares with SVD:

```{r}
temp_mat <- t(info_mat) %*% info_mat
S <- svd(temp_mat)
sigma <- diag(S$d, cap_p, cap_p)

# testing against matlab values:
if(test_flag == 1){
  matlab_sigma <- as.matrix(read.csv("./test/gpc_matlab/sigma.csv", header = F))
  all.equal(sigma, matlab_sigma, check.attributes = F)
}

s_coeffs <- S$v %*% solve(sigma) %*% Conj(t.default(S$u)) %*% t(info_mat) %*% Y

# testing against matlab values:
if(test_flag == 1){
  matlab_sCoeffs <- as.matrix(read.csv("./test/gpc_matlab/s_coeffs.csv", header = F))
  all.equal(s_coeffs, matlab_sCoeffs, check.attributes = F)
}
```

Compute errors between gPC surrogate and true model function:

```{r}
sobol_seed <- 14
test_errors <- compute_validation_and_testing_error(n, s_coeffs, alpha_mat, 
                                     param_combo_subset, sobol_seed)
```

Report results:

```{r echo = FALSE}
err_rel_train <- abs(test_errors$training$gpc_dat - test_errors$training$real_dat) / abs(test_errors$training$real_dat) * 100
print("~*~._.~*~ Training set ~*~._.~*~")
print(paste("median error:", round(median(err_rel_train, na.rm = T), digits = 2)))
print(paste(c("min error:", "max error:"), round(range(err_rel_train), digits = 2)))
print(paste("standard deviation:", round(sd(err_rel_train, na.rm = T),digits = 2)))

err_rel_test <- abs(test_errors$testing$gpc_dat - test_errors$testing$real_dat) / abs(test_errors$testing$real_dat) * 100
print("~*~._.~*~ Testing set ~*~._.~*~");
print(paste("median error:", round(median(err_rel_test, na.rm = T), digits = 2)))
print(paste(c("min error:", "max error:"), round(range(err_rel_test), digits = 2)))
print(paste("standard deviation:", round(sd(err_rel_test, na.rm = T), digits = 2)))
```

Testing expansion on 2D subspace:

```{r}
plots <- test_gpc_expansion(s_coeffs, alpha_mat)

plots[[1]] + plots[[2]] + plot_layout(guides = "collect")
```

Compute the Sobol indices: 

```{r}
sobols <- compute_sobol_indices(s_coeffs, alpha_mat)
```

Report Sobol Indices:

```{r echo=F}
print("~*~._.~*~ 1st order Sobol Indices ~*~._.~*~")
print(paste0("s", 1:3, ": ", round(sobols[["s_first"]], digits = 4)))
print("~*~._.~*~ 2nd order Sobol Indices ~*~._.~*~")
print(paste0("s", c(12, 13, 23), ": ", round(sobols[["s2nd"]][!is.na(sobols[["s2nd"]])], 
                                             digits = 4)))
print("~*~._.~*~ s123 Sobol index ~*~._.~*~")
print(round(sobols[["s123"]][1], digits = 4))
print("~*~._.~*~ Total-order Sobol indices ~*~._.~*~")
print(paste0("sT", 1:3, ": ", round(sobols[["s_total"]], digits = 4)))
```
## Modify gPC parameter combinations to fit chose parameter ranges

Once the gPC parameter combinations are generated, you can re-scale the range of each parameter range to fit your particular parameter range of interest. Below is a demonstration of how to accomplish this for the foil study with the ranges: 

 * Reynolds number: 1e6 to 1e9
 * Angle of Attack: 0 to 15
 * Camber: 0.005 to 0.20 
 
```{r}
Re_range <- c(1e6, 1e9)
aoa_range <- c(0, 15)
camber_range <- c(0.005, 0.20)

final_set <- data.frame("Re" = rep(NA, nrow(param_combo)), 
                        "aoa" = rep(NA, nrow(param_combo)),
                        "camber" = rep(NA, nrow(param_combo)))
```
 
Transform `aoa` and `camber`: 

```{r}
final_set$aoa <- ((param_combo[,2] + 1)/2)*max(aoa_range)
final_set$camber <-  (((param_combo[,3] + 1)/2))*(max(camber_range)  - min(camber_range)) + min(camber_range)
```

Note that the Reynolds number has to options for gPC and NN: a log-transformed range and a non-log transformed range. This is to accommodate the very large range of numbers (three orders of magnitude). 

Transform the first column of the param_combo to fit the Re range for non-log and log transformed: 

```{r}
Re_nolog <- (((param_combo[,1] + 1)/2))*(max(Re_range)  - min(Re_range)) + min(Re_range)
Re_log <- (((param_combo[,1] + 1)/2))*(log10(max(Re_range))  - log10(min(Re_range))) + log10(min(Re_range))
Re_log <- 10^(Re_log)
```

Now set the Re preference and save the resulting data frames: 

```{r}
# Log transformed set
final_set$Re <- Re_log
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_LogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
# Non-log transformed set
final_set$Re <- Re_nolog
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```

### Next Steps... 

The next step is to run the `Creating_cambers.Rmd` in RStudio to generate the airfoil files. 

