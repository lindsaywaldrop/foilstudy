---
title: "Generating parameter spaces using R"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup}
library(pracma)
library(spacefillr)
library(ggplot2)
library(patchwork)
```

## Parameters of interest and their ranges 

In this study, we examine the output of coefficients of lift and drag on airfoils as a response to changes in the Reynolds number, angle of attack, and airfoil camber. We use the following parameter ranges to establish our parameter sampling spaces: 

 * Reynolds number: 1e6 to 1e9
 * Angle of Attack: 0 to 15
 * Camber: 0.005 to 0.20 

```{r}
Re_range <- c(1e6, 1e9)
aoa_range <- c(0, 15)
camber_range <- c(0.005, 0.20)
```

We use three methods for generating parameter sampling spaces: __grid sampling__, __generalized polynomial chaos__, and __neural network sampling__. Each of these are generated in the following sections of this code document and can also be found in the MATLAB script `./doc/Generating_points.MATLAB.mlx`. Output from this code will be csv files located in `./data/parameters/`.

## Producing the grid sampled parameter space

This is equivalent code to the grid sampling in the MATLAB script `./doc/Generating_points.MATLAB.mlx`, here reproduced in R. 

Since all methods use the same number of simulations, the uniform spacing of our grid will need to be divided by the steps of the cubic root of 343: 

```{r}
steps <- nthroot(343, 3)
grid_spacing_Re <- (Re_range[2] - Re_range[1])/(steps - 1)
grid_spacing_aoa <- (aoa_range[2] - aoa_range[1])/(steps - 1)
grid_spacing_camber <- (camber_range[2] - camber_range[1])/(steps - 1)
```

Create a vector of the individual values that will be run for each parameter:

```{r}
re_vec <- seq(Re_range[1], Re_range[2], by = grid_spacing_Re)
aoa_vec <- seq(aoa_range[1], aoa_range[2], by = grid_spacing_aoa)
camber_vec <- seq(camber_range[1], camber_range[2], by = grid_spacing_camber)
```

Extend all parameters to create a full parameter combination set using `mesh()` from the plot3D package. (It's not recommended to load the plot3D library unless you want XQuartz or similar plot device open in your RStudio session.) 

```{r}
grid_3d <- plot3D::mesh(re_vec, aoa_vec, camber_vec)
```

Reshape each individual parameter array into a 1D vector, then combine them into a 343 x 3 data frame:

```{r}
params_grid <- data.frame("Re" = as.vector(grid_3d[[1]]),
                          "aoa" = as.vector(grid_3d[[2]]), 
                          "camber" = as.vector(grid_3d[[3]]))
```

Save the resulting data frame:

```{r}
write.table(signif(params_grid, digits = 5), file = paste0("./data/parameters/grid_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```

## Producing gPC parameter space

This work is a validated translation of Nick Battista's MATLAB code into R. This section steps through the entire process found in `./src/matlab/USER_RUN_gPC_Expansion.m` that is called as a function in the MATLAB live script `./doc/Generating_points_MATLAB.mlx` in R. 

Load custom functions: 

```{r}
source("./src/r-scripts/gPC_functions.R")
source("./src/r-scripts/gpc_user_specified_model.R")
```

Initial parameters: 

 - `test_flag` will test the results against expected values produced by the code in MATLAB.`TRUE` should be displayed in the output of each code chunk (at least once) if testing is successful. If you wish to intrinsically validate this code, use `1` to test, otherwise `0` will turn testing off. 

```{r initial-parameters}
test_flag <- 0
```

Set gPC parameters:

 - `n`: the number of parameters in your data set. 
 - `p`: the order of polynomial you wish to use. Using lower values of `p` may not capture non-linear aspects of the performance space, but will require fewer full simulations. Higher `p` will require more simulations.

```{r set-gpc-parameters}
n <- 3
p <- 6
cap_p <- nchoosek(n + p, p)
```

Find collocation points:

```{r collocation-points}
poly_roots <- Legendre_roots(p + 1, test_flag)
```

Find combinations of all collocation points: 

```{r}
param_combo <- compute_all_collo_pt_combos(n, poly_roots, test_flag)
```

Get subset of all parameter combinations for least squares: 

```{r}
n_subset <- 1 * (n - 1) * cap_p
param_combo_subset <- sample_parameter_combos(n_subset, param_combo, test_flag)
```

You can use either the full set `param_combo` or the smaller subset `param_combo_subset` for running your full simulations. Here, we use the full set. 

### Evaluate and test parameter combinations

Multivariable Legendre polynomial ordering:

```{r}
alpha_mat <- create_polynomial_ordering(n, p, test_flag)
```

Create information matrix: 

```{r}
info_mat <- create_info_matrix(n, p, cap_p, param_combo_subset, alpha_mat, test_flag)
```

Evaluate user-specified model for particular parameter combos:

```{r}
Y <- rep(0, nrow(param_combo_subset))
for(i in 1:nrow(param_combo_subset)){
  Y[i] <- user_specified_model(param_combo_subset[i, ])
}

# testing against matlab values:
if(test_flag == 1){
  matlab_Y <- read.csv("./test/gpc_matlab/Y.csv", header = F)
  all.equal(Y, matlab_Y[, 1])
}
```

Solve for coefficients via least-squares with SVD:

```{r}
temp_mat <- t(info_mat) %*% info_mat
S <- svd(temp_mat)
sigma <- diag(S$d, cap_p, cap_p)

# testing against matlab values:
if(test_flag == 1){
  matlab_sigma <- as.matrix(read.csv("./test/gpc_matlab/sigma.csv", header = F))
  all.equal(sigma, matlab_sigma, check.attributes = F)
}

s_coeffs <- S$v %*% solve(sigma) %*% Conj(t.default(S$u)) %*% t(info_mat) %*% Y

# testing against matlab values:
if(test_flag == 1){
  matlab_sCoeffs <- as.matrix(read.csv("./test/gpc_matlab/s_coeffs.csv", header = F))
  all.equal(s_coeffs, matlab_sCoeffs, check.attributes = F)
}
```

Compute errors between gPC surrogate and true model function:

```{r}
sobol_seed <- 14
test_errors <- compute_validation_and_testing_error(n, s_coeffs, alpha_mat, 
                                     param_combo_subset, sobol_seed)
```

Report results:

```{r echo = FALSE}
err_rel_train <- abs(test_errors$training$gpc_dat - test_errors$training$real_dat) / abs(test_errors$training$real_dat) * 100
print("~*~._.~*~ Training set ~*~._.~*~")
print(paste("median error:", round(median(err_rel_train, na.rm = T), digits = 2)))
print(paste(c("min error:", "max error:"), round(range(err_rel_train), digits = 2)))
print(paste("standard deviation:", round(sd(err_rel_train, na.rm = T),digits = 2)))

err_rel_test <- abs(test_errors$testing$gpc_dat - test_errors$testing$real_dat) / abs(test_errors$testing$real_dat) * 100
print("~*~._.~*~ Testing set ~*~._.~*~");
print(paste("median error:", round(median(err_rel_test, na.rm = T), digits = 2)))
print(paste(c("min error:", "max error:"), round(range(err_rel_test), digits = 2)))
print(paste("standard deviation:", round(sd(err_rel_test, na.rm = T), digits = 2)))
```

Testing expansion on 2D subspace:

```{r}
plots <- test_gpc_expansion(s_coeffs, alpha_mat)

plots[[1]] + plots[[2]] + plot_layout(guides = "collect")
```

Compute the Sobol indices: 

```{r}
sobols <- compute_sobol_indices(s_coeffs, alpha_mat)
```

Report Sobol Indices:

```{r echo=F}
print("~*~._.~*~ 1st order Sobol Indices ~*~._.~*~")
print(paste0("s", 1:3, ": ", round(sobols[["s_first"]], digits = 4)))
print("~*~._.~*~ 2nd order Sobol Indices ~*~._.~*~")
print(paste0("s", c(12, 13, 23), ": ", round(sobols[["s2nd"]][!is.na(sobols[["s2nd"]])], 
                                             digits = 4)))
print("~*~._.~*~ s123 Sobol index ~*~._.~*~")
print(round(sobols[["s123"]][1], digits = 4))
print("~*~._.~*~ Total-order Sobol indices ~*~._.~*~")
print(paste0("sT", 1:3, ": ", round(sobols[["s_total"]], digits = 4)))
```

### Modify gPC parameter combinations to fit chose parameter ranges

Once the gPC parameter combinations are generated, you can re-scale the range of each parameter range to fit your particular parameter range of interest. Below is a demonstration of how to accomplish this for the foil study with the ranges defined above: 

```{r}
final_set <- data.frame("Re" = rep(NA, nrow(param_combo)), 
                        "aoa" = rep(NA, nrow(param_combo)),
                        "camber" = rep(NA, nrow(param_combo)))
```
 
Transform `aoa` and `camber`: 

```{r}
final_set$aoa <- ((param_combo[,2] + 1)/2)*max(aoa_range)
final_set$camber <-  (((param_combo[,3] + 1)/2))*(max(camber_range)  - min(camber_range)) + min(camber_range)
```

Note that the Reynolds number has to options for gPC and NN: a log-transformed range and a non-log transformed range. This is to accommodate the very large range of numbers (three orders of magnitude). 

Transform the first column of the param_combo to fit the Re range for non-log and log transformed: 

```{r}
Re_nolog <- (((param_combo[,1] + 1)/2))*(max(Re_range)  - min(Re_range)) + min(Re_range)
Re_log <- (((param_combo[,1] + 1)/2))*(log10(max(Re_range))  - log10(min(Re_range))) + log10(min(Re_range))
Re_log <- 10^(Re_log)
```

Now set the Re preference and save the resulting data frames: 

```{r}
# Log transformed set
final_set$Re <- Re_log
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_LogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
# Non-log transformed set
final_set$Re <- Re_nolog
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```



## Next Steps... 

The next step is to run the `Creating_cambers.Rmd` in RStudio to generate the airfoil files. 

