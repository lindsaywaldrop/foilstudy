---
title: "Generating parameter spaces using R"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup}
library(pracma)
library(spacefillr)
library(ggplot2)
library(patchwork)
```

## Parameters of interest and their ranges 

In this study, we examine the output of coefficients of lift and drag on airfoils as a response to changes in the Reynolds number, angle of attack, and airfoil camber. We use the following parameter ranges to establish our parameter sampling spaces: 

 * Reynolds number: 1e6 to 1e9
 * Angle of Attack: 0 to 15
 * Camber: 0.005 to 0.20 

```{r}
Re_range <- c(1e6, 1e9)
aoa_range <- c(0, 15)
camber_range <- c(0.005, 0.20)
```

We use three methods for generating parameter sampling spaces: __grid sampling__, __generalized polynomial chaos__, and __neural network sampling__. Each of these are generated in the following sections of this code document and can also be found in the MATLAB script `./doc/Generating_points.MATLAB.mlx`. Output from this code will be csv files located in `./data/parameters/`.

## Producing the grid sampled parameter space

This is equivalent code to the grid sampling in the MATLAB script `./doc/Generating_points.MATLAB.mlx`, here reproduced in R. 

Load custom functions: 

```{r}
source("./src/r-scripts/grid_functions.R")
```

Since all methods use the same number of simulations, the uniform spacing of our grid will need to be divided by the steps of the cubic root of 343: 

```{r}
steps <- nthroot(343, 3)
grid_spacing_Re <- (Re_range[2] - Re_range[1])/(steps - 1)
grid_spacing_aoa <- (aoa_range[2] - aoa_range[1])/(steps - 1)
grid_spacing_camber <- (camber_range[2] - camber_range[1])/(steps - 1)
```

Create a vector of the individual values that will be run for each parameter:

```{r}
re_vec <- seq(Re_range[1], Re_range[2], by = grid_spacing_Re)
aoa_vec <- seq(aoa_range[1], aoa_range[2], by = grid_spacing_aoa)
camber_vec <- seq(camber_range[1], camber_range[2], by = grid_spacing_camber)
```

Extend all parameters to create a full parameter combination set:

```{r}
grid_3d <- mesh_array(re_vec, aoa_vec, camber_vec)
```

Reshape each individual parameter array into a 1D vector, then combine them into a 343 x 3 data frame:

```{r}
params_grid <- data.frame("Re" = as.vector(grid_3d[[1]]),
                          "aoa" = as.vector(grid_3d[[2]]), 
                          "camber" = as.vector(grid_3d[[3]]))
```

Save the resulting data frame:

```{r}
write.table(signif(params_grid, digits = 5), file = paste0("./data/parameters/grid_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```

## Producing gPC parameter space

Load custom functions: 

```{r}
source("./src/r-scripts/gpc_functions.R")
```

Set gPC parameters:

 - `n`: the number of parameters in your data set. 
 - `p`: the order of polynomial you wish to use. Using lower values of `p` may not capture non-linear aspects of the performance space, but will require fewer full simulations. Higher `p` will require more simulations.

```{r set-gpc-parameters}
n <- 3
p <- 6
cap_p <- nchoosek(n + p, p)
```

Find collocation points:

```{r collocation-points}
poly_roots <- Legendre_roots(p + 1)
```

Find combinations of all collocation points: 

```{r}
param_combo <- compute_all_collo_pt_combos(n, poly_roots)
```

### Modify gPC parameter combinations to fit chose parameter ranges

Once the gPC parameter combinations are generated, you can re-scale the range of each parameter range to fit your particular parameter range of interest. Below is a demonstration of how to accomplish this for the foil study with the ranges defined above: 

```{r}
final_set <- data.frame("Re" = rep(NA, nrow(param_combo)), 
                        "aoa" = rep(NA, nrow(param_combo)),
                        "camber" = rep(NA, nrow(param_combo)))
```
 
Transform `aoa` and `camber`: 

```{r}
final_set$aoa <- ((param_combo[,2] + 1)/2)*max(aoa_range)
final_set$camber <-  (((param_combo[,3] + 1)/2))*(max(camber_range)  - min(camber_range)) + min(camber_range)
```

Note that the Reynolds number has to options for gPC and NN: a log-transformed range and a non-log transformed range. This is to accommodate the very large range of numbers (three orders of magnitude). 

Transform the first column of the param_combo to fit the Re range for non-log and log transformed: 

```{r}
Re_nolog <- (((param_combo[,1] + 1)/2))*(max(Re_range)  - min(Re_range)) + min(Re_range)
Re_log <- (((param_combo[,1] + 1)/2))*(log10(max(Re_range))  - log10(min(Re_range))) + log10(min(Re_range))
Re_log <- 10^(Re_log)
```

Now set the Re preference and save the resulting data frames: 

```{r}
# Log transformed set
final_set$Re <- Re_log
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_LogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
# Non-log transformed set
final_set$Re <- Re_nolog
write.table(signif(final_set, digits = 5), file = paste0("./data/parameters/gPC_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```

## Producing the Neural Network parameter space

It's important that the data set chosen to train the neural network model (the set that will be run with the full simulation model for output) is chosen differently than the testing data set for validation. Therefore, we will use a Sobol sequence from the `spacefillr` package to generate the training data set for the no-log transformed set. The testing set will log-transformed and generated by R's pseudorandom number generator `runif()`.

Here, the `n_train` value will be the number of points in the training data set, `n_test` will be the number of points in the testing data set, and `n` is the number of parameters in our data set:

```{r}
n_train <- 343
n_test <- 343
n <- 3
nolog_nn <- spacefillr::generate_sobol_set(n_train, n, seed = 25)
log_nn <- matrix(runif(n_test*n), nrow = n_test, ncol = n)
```

Since the Sobol' sequences are on the range [0,1], we need to rescale these to take on the range of the parameters of interest. `aoa` and `camber` are straightforward: 

```{r}
nolog_nn[, 2] <- ((nolog_nn[, 2] + 1)/2)*max(aoa_range)
log_nn[, 2] <- ((log_nn[, 2] + 1)/2)*max(aoa_range)
nolog_nn[, 3] <- (((nolog_nn[, 3] + 1)/2))*(max(camber_range)  - min(camber_range)) + min(camber_range)
log_nn[, 3] <- (((log_nn[, 3] + 1)/2))*(max(camber_range)  - min(camber_range)) + min(camber_range)
```

And Reynold's number will take on a no-log transformed range for `nolog_nn` and a log-transformed range for `log_nn`: 

```{r}
nolog_nn[, 1] <- (((nolog_nn[,1] + 1)/2))*(max(Re_range)  - min(Re_range)) + min(Re_range)
log_nn[, 1] <- (((log_nn[,1] + 1)/2))*(log10(max(Re_range))  - log10(min(Re_range))) + log10(min(Re_range))
log_nn[, 1] <- 10^(log_nn[,1])
```

Now save the sets: 

```{r}
# Log transformed set
write.table(signif(log_nn, digits = 5), file = paste0("./data/parameters/NN_Params_LogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
# Non-log transformed set
write.table(signif(nolog_nn, digits = 5), file = paste0("./data/parameters/NN_Params_noLogRe.csv"), 
              row.names = F, col.names = F, sep = ",")
```

## Next Step... 

The next step is to run the `Creating_cambers.Rmd` in RStudio to generate the airfoil files. 

